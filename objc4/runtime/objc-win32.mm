
#include "objc-config.h"

#if TARGET_OS_WIN32

#include <stdio.h>
#include <stdlib.h>

#define WIN32_LEAN_AND_MEAN
#define BOOL WINBOOL
#include <windows.h>
#undef BOOL

#include "objc-private.h"
#include "objc-os.h"
#include "objc-runtime-new.h"

/*
WINBOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
		// _objc_init();
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
*/


static struct _objc_initializer_
{
	_objc_initializer_()
	{
		_objc_init();
	}
} _objc_initializer_var;



OBJC_EXPORT void _objc_load_image(HMODULE image, header_info *hinfo)
{
    prepare_load_methods(hinfo);
    call_load_methods();
}


OBJC_EXPORT void _objc_unload_image(HMODULE image, header_info *hinfo)
{
    _objc_fatal("image unload not supported");
}


OBJC_EXPORT header_info *_objc_init_image(HMODULE image)
{
	static const objc_image_info image_info = {0, 0};

    header_info *hi = (header_info *)_malloc_internal(sizeof(header_info));
    size_t count, i;

    hi->mhdr = (const headerType *)image;
    hi->info = &image_info;
    hi->allClassesRealized = NO;
    hi->moduleName = (TCHAR *)malloc(MAX_PATH * sizeof(TCHAR));
    GetModuleFileName((HMODULE)(hi->mhdr), hi->moduleName, MAX_PATH * sizeof(TCHAR));

    appendHeader(hi);

    _read_images(&hi, 1);

    return hi;
}


#define GETSECT(_name, _type, _sectname) \
	OBJC_EXPORT _type* _name(const header_info *hi, size_t *outCount) { \
		_type* data = & _sectname ## _START; \
		*outCount = (& _sectname ## _END - data) / sizeof(_type); \
		return data; }


// Defining a macro for this mess below turns out to be incredibly difficult
// (though not impossible, using _Pragma(), extra levels of macro indirection,
// etc.) On the other hand, defining this in an assembly module has its own
// problems, such as clang not accepting .section directives generated by
// clang -S. So, just mostly copy paste here:

#pragma section(".__objc_selrefs$A",long,read,write)
#pragma data_seg(".__objc_selrefs$A")
SEL __objc_selrefs_START = {};
#pragma section(".__objc_selrefs$C",long,read,write)
#pragma data_seg(".__objc_selrefs$C")
SEL __objc_selrefs_END = {};

#pragma section(".__objc_msgrefs$A",long,read,write)
#pragma data_seg(".__objc_msgrefs$A")
message_ref_t __objc_msgrefs_START = {};
#pragma section(".__objc_msgrefs$C",long,read,write)
#pragma data_seg(".__objc_msgrefs$C")
message_ref_t __objc_msgrefs_END = {};

#pragma section(".__objc_classrefs$A",long,read,write)
#pragma data_seg(".__objc_classrefs$A")
class_t * __objc_classrefs_START = {};
#pragma section(".__objc_classrefs$C",long,read,write)
#pragma data_seg(".__objc_classrefs$C")
class_t * __objc_classrefs_END = {};

#pragma section(".__objc_superrefs$A",long,read,write)
#pragma data_seg(".__objc_superrefs$A")
class_t * __objc_superrefs_START = {};
#pragma section(".__objc_superrefs$C",long,read,write)
#pragma data_seg(".__objc_superrefs$C")
class_t * __objc_superrefs_END = {};

#pragma section(".__objc_classlist$A",long,read,write)
#pragma data_seg(".__objc_classlist$A")
classref_t __objc_classlist_START = {};
#pragma section(".__objc_classlist$C",long,read,write)
#pragma data_seg(".__objc_classlist$C")
classref_t __objc_classlist_END = {};

#pragma section(".__objc_nlclslist$A",long,read,write)
#pragma data_seg(".__objc_nlclslist$A")
classref_t __objc_nlclslist_START = {};
#pragma section(".__objc_nlclslist$C",long,read,write)
#pragma data_seg(".__objc_nlclslist$C")
classref_t __objc_nlclslist_END = {};

#pragma section(".__objc_catlist$A",long,read,write)
#pragma data_seg(".__objc_catlist$A")
category_t * __objc_catlist_START = {};
#pragma section(".__objc_catlist$C",long,read,write)
#pragma data_seg(".__objc_catlist$C")
category_t * __objc_catlist_END = {};

#pragma section(".__objc_nlcatlist$A",long,read,write)
#pragma data_seg(".__objc_nlcatlist$A")
category_t * __objc_nlcatlist_START = {};
#pragma section(".__objc_nlcatlist$C",long,read,write)
#pragma data_seg(".__objc_nlcatlist$C")
category_t * __objc_nlcatlist_END = {};

#pragma section(".__objc_protolist$A",long,read,write)
#pragma data_seg(".__objc_protolist$A")
protocol_t * __objc_protolist_START = {};
#pragma section(".__objc_protolist$C",long,read,write)
#pragma data_seg(".__objc_protolist$C")
protocol_t * __objc_protolist_END = {};

#pragma section(".__objc_protorefs$A",long,read,write)
#pragma data_seg(".__objc_protorefs$A")
protocol_t * __objc_protorefs_START = {};
#pragma section(".__objc_protorefs$C",long,read,write)
#pragma data_seg(".__objc_protorefs$C")
protocol_t * __objc_protorefs_END = {};

GETSECT(_getObjc2SelectorRefs,        SEL,             __objc_selrefs)
GETSECT(_getObjc2MessageRefs,         message_ref_t,   __objc_msgrefs);
GETSECT(_getObjc2ClassRefs,           class_t *,       __objc_classrefs);
GETSECT(_getObjc2SuperRefs,           class_t *,       __objc_superrefs);
GETSECT(_getObjc2ClassList,           classref_t,       __objc_classlist);
GETSECT(_getObjc2NonlazyClassList,    classref_t,       __objc_nlclslist);
GETSECT(_getObjc2CategoryList,        category_t *,    __objc_catlist);
GETSECT(_getObjc2NonlazyCategoryList, category_t *,    __objc_nlcatlist);
GETSECT(_getObjc2ProtocolList,        protocol_t *,    __objc_protolist);
GETSECT(_getObjc2ProtocolRefs,        protocol_t *,    __objc_protorefs);



/*
// Boundary symbols for metadata sections

#pragma section(".objc_module_info$A",long,read,write)
#pragma data_seg(".objc_module_info$A")
static uintptr_t __objc_modStart = 0;
#pragma section(".objc_module_info$C",long,read,write)
#pragma data_seg(".objc_module_info$C")
static uintptr_t __objc_modEnd = 0;

#pragma section(".objc_protocol$A",long,read,write)
#pragma data_seg(".objc_protocol$A")
static uintptr_t __objc_protoStart = 0;
#pragma section(".objc_protocol$C",long,read,write)
#pragma data_seg(".objc_protocol$C")
static uintptr_t __objc_protoEnd = 0;

#pragma section(".objc_image_info$A",long,read,write)
#pragma data_seg(".objc_image_info$A")
static uintptr_t __objc_iiStart = 0;
#pragma section(".objc_image_info$C",long,read,write)
#pragma data_seg(".objc_image_info$C")
static uintptr_t __objc_iiEnd = 0;

#pragma section(".objc_message_refs$A",long,read,write)
#pragma data_seg(".objc_message_refs$A")
static uintptr_t __objc_selrefsStart = 0;
#pragma section(".objc_message_refs$C",long,read,write)
#pragma data_seg(".objc_message_refs$C")
static uintptr_t __objc_selrefsEnd = 0;

#pragma section(".objc_class_refs$A",long,read,write)
#pragma data_seg(".objc_class_refs$A")
static uintptr_t __objc_clsrefsStart = 0;
#pragma section(".objc_class_refs$C",long,read,write)
#pragma data_seg(".objc_class_refs$C")
static uintptr_t __objc_clsrefsEnd = 0;

#pragma data_seg()

// Merge all metadata into .data
// fixme order these by usage?
#pragma comment(linker, "/MERGE:.objc_module_info=.data")
#pragma comment(linker, "/MERGE:.objc_protocol=.data")
#pragma comment(linker, "/MERGE:.objc_image_info=.data")
#pragma comment(linker, "/MERGE:.objc_message_refs=.data")
#pragma comment(linker, "/MERGE:.objc_class_refs=.data")
*/

// Image initializers

static header_info *__hinfo = NULL;  // cookie from runtime
extern IMAGE_DOS_HEADER __ImageBase;  // this image's header

OBJC_EXPORT void _objc_init(void)
{
    static bool initialized = false;
    if (initialized) return;
    initialized = true;

    __hinfo = _objc_init_image((HMODULE)&__ImageBase);
	environ_init();
	tls_init();
	lock_init();
	sel_init(NO, 3500);  // old selector heuristic
	exception_init();
    _objc_load_image((HMODULE)&__ImageBase, __hinfo);
}

/*
static void __objc_unload(void)
{
    _objc_unload_image((HMODULE)&__ImageBase, __hinfo);
}

static int __objc_load(void)
{
    _objc_load_image((HMODULE)&__ImageBase, __hinfo);
    return 0;
}
*/

// run _objc_init_image ASAP
// #pragma section(".CRT$XIAA",long,read,write)
// #pragma data_seg(".CRT$XIAA")
// static void *__objc_init_fn = &__objc_init;

// run _objc_load_image (+load methods) after all other initializers; 
// otherwise constant NSStrings are not initialized yet
// #pragma section(".CRT$XCUO",long,read,write)
// #pragma data_seg(".CRT$XCUO")
// static void *__objc_load_fn = &__objc_load;

// _objc_unload_image is called by atexit(), not by an image terminator

#pragma data_seg()

#endif
